# Лабораторная работа 3. Реализация серверной части на FastAPI. Документирование API.

## Цель работы
Овладеть практическими навыками реализации серверной части (backend) приложений средствами FastAPI с асинхронным взаимодействием с базой данных.

---

## Архитектура приложения

### Общая структура

Приложение построено по принципу **слоистой архитектуры** с чётким разделением ответственности:

```
app/
├── main.py                 # Точка входа, конфигурация FastAPI
├── api/
│   ├── routers/            # Эндпоинты (контроллеры)
│   └── schemas/            # Pydantic-схемы валидации
└── core/
    ├── database.py         # Подключение к БД
    ├── settings/           # Конфигурация приложения
    └── db/
        ├── models/         # SQLAlchemy ORM-модели
        └── crud/           # Операции с данными
```

### Принципы организации кода

1. **Роутеры (Routers)** — определяют HTTP-эндпоинты и обрабатывают запросы
2. **Схемы (Schemas)** — Pydantic-модели для валидации входных/выходных данных
3. **CRUD-функции** — асинхронные функции для работы с БД, изолированные по сущностям
4. **Модели (Models)** — SQLAlchemy ORM-классы, описывающие структуру таблиц

---

## Модели данных

### User (Пользователь)
Хранит учётные данные пользователя: `username`, `email`, `hashed_password`, `is_active`, `created_at`. Связан с моделями `UserProfile`, `Reservation` и `Review` через one-to-many отношения.

### UserProfile (Профиль пользователя)
Дополнительная информация о пользователе: `date_of_birth`. Связан с `User` через one-to-one отношение с каскадным удалением.

### Tour (Тур)
Основная сущность туристического агентства: `title`, `agency`, `description`, `start_date`, `end_date`, `price`, `city`, `payment_terms`. Имеет связи с `Reservation` и `Review`.

### Reservation (Бронирование)
Бронирование тура пользователем: `tour_id`, `user_id`, `guests`, `notes`, `confirmed`, `created_at`. Использует внешние ключи с каскадным удалением.

### Review (Отзыв)
Отзыв пользователя о туре: `tour_id`, `user_id`, `text`, `rating` (1-10), `created_at`. При удалении пользователя `user_id` устанавливается в `NULL` (SET NULL).

---

## API Эндпоинты

### Аутентификация (`/auth`)

| Метод | Эндпоинт | Описание | Авторизация |
|-------|----------|----------|-------------|
| POST | `/auth/register` | Регистрация нового пользователя | Нет |
| POST | `/auth/login` | Авторизация и получение JWT-токена | Нет |
| GET | `/auth/me` | Информация о текущем пользователе | Да |
| GET | `/auth/me/profile` | Получение профиля пользователя | Да |
| PUT | `/auth/me/profile` | Обновление профиля | Да |

**Архитектурные особенности:**

- Роутер использует `OAuth2PasswordBearer` для извлечения токена из заголовка `Authorization`
- Функция `get_current_user` — dependency для защищённых эндпоинтов, декодирует JWT и возвращает пользователя
- Регистрация проверяет уникальность `username` и `email` через CRUD-функции `get_user_by_username` и `get_user_by_email`
- Пароль хешируется через `CryptContext` (bcrypt) в модуле `security.py`
- JWT создаётся функцией `create_access_token` с настраиваемым временем жизни

---

### Туры (`/tours`)

| Метод | Эндпоинт | Описание | Авторизация |
|-------|----------|----------|-------------|
| POST | `/tours/` | Создание нового тура | Да |
| GET | `/tours/` | Список туров с пагинацией и фильтрацией | Нет |
| GET | `/tours/{tour_id}` | Получение тура по ID | Нет |
| PUT | `/tours/{tour_id}` | Обновление тура | Да |
| DELETE | `/tours/{tour_id}` | Удаление тура | Да |

**Архитектурные особенности:**

- Каждая CRUD-операция вынесена в отдельный файл: `create_tour.py`, `get_tour.py`, `get_all_tours.py`, `update_tour.py`, `delete_tour.py`
- Получение списка туров поддерживает:
  - **Пагинацию** через параметры `limit` и `offset`
  - **Фильтрацию по городу** через параметр `city`
- Схемы Pydantic: `TourCreate` (создание), `TourUpdate` (частичное обновление), `TourResponse` (ответ)
- `TourUpdate` использует `exclude_unset=True` для partial update — обновляются только переданные поля

---

### Бронирования (`/reservations`)

| Метод | Эндпоинт | Описание | Авторизация |
|-------|----------|----------|-------------|
| POST | `/reservations/` | Создание бронирования | Да |
| GET | `/reservations/my` | Бронирования текущего пользователя | Да |
| GET | `/reservations/{id}` | Получение бронирования по ID | Да |
| PUT | `/reservations/{id}` | Обновление бронирования | Да |
| DELETE | `/reservations/{id}` | Удаление бронирования | Да |

**Архитектурные особенности:**

- Все операции требуют авторизации
- Реализована **проверка владельца**: пользователь может работать только со своими бронированиями
- При создании проверяется существование тура через `get_tour_by_id`
- После создания/обновления бронирование перезагружается с JOIN на `Tour` для возврата полной информации
- Схема `ReservationWithTour` включает вложенный объект тура

---

### Отзывы (`/reviews`)

| Метод | Эндпоинт | Описание | Авторизация |
|-------|----------|----------|-------------|
| POST | `/reviews/` | Создание отзыва | Да |
| GET | `/reviews/tour/{tour_id}` | Отзывы по туру | Нет |
| GET | `/reviews/{review_id}` | Получение отзыва по ID | Нет |
| PUT | `/reviews/{review_id}` | Обновление отзыва | Да |
| DELETE | `/reviews/{review_id}` | Удаление отзыва | Да |

**Архитектурные особенности:**

- Получение отзывов по туру — публичный эндпоинт с пагинацией
- Изменение/удаление доступно только автору отзыва
- Схема `ReviewWithUser` обогащает ответ именем пользователя через relationship
- Рейтинг валидируется Pydantic (значения 1-10)

---

## Асинхронная работа с базой данных

### Подключение к БД

Используется асинхронный движок SQLAlchemy с драйвером `asyncpg`:

- `create_async_engine` создаёт асинхронное подключение к PostgreSQL
- `async_sessionmaker` генерирует фабрику асинхронных сессий
- Dependency `get_async_session` — асинхронный генератор для инъекции сессии в роутеры

### Lifespan Events

FastAPI использует контекстный менеджер `lifespan` для:
- **Startup**: инициализация БД, создание таблиц
- **Shutdown**: корректное закрытие соединений

---

## Безопасность

### JWT-аутентификация

1. Пользователь отправляет `username` и `password` на `/auth/login`
2. Сервер проверяет credentials через `verify_password` (bcrypt)
3. При успехе генерируется JWT с payload `{"sub": username, "exp": expiration}`
4. Токен возвращается клиенту в формате `{"access_token": "...", "token_type": "bearer"}`
5. Защищённые эндпоинты извлекают токен через `OAuth2PasswordBearer` и декодируют через `decode_token`

### Конфигурация

Секретные данные загружаются из переменных окружения через `pydantic-settings`:
- `SECRET_KEY` — ключ подписи JWT
- `ALGORITHM` — алгоритм подписи (HS256)
- `ACCESS_TOKEN_EXPIRE_MINUTES` — время жизни токена

---

## Контейнеризация

### Docker Compose

Приложение запускается в двух контейнерах:

1. **app** (FastAPI) — зависит от готовности БД через `healthcheck`
2. **db** (PostgreSQL 17) — с volume для персистентности данных

### Healthcheck

PostgreSQL проверяется командой `pg_isready`, FastAPI стартует только после успешной проверки.

---

## Документация API

FastAPI автоматически генерирует интерактивную документацию:

- **Swagger UI**: `/docs`
- **ReDoc**: `/redoc`

Дополнительная документация проекта создана с помощью **MkDocs Material**.

---

## Выводы

В ходе выполнения лабораторной работы были изучены:

1. **FastAPI** — современный асинхронный фреймворк для создания REST API
2. **SQLAlchemy 2.0** — асинхронный ORM с декларативным описанием моделей через `Mapped` и `mapped_column`
3. **Pydantic** — валидация данных и сериализация через схемы
4. **JWT-аутентификация** — реализация защищённых эндпоинтов с OAuth2
5. **Слоистая архитектура** — разделение на роутеры, схемы, CRUD и модели
6. **Docker Compose** — оркестрация многоконтейнерного приложения
7. **Alembic** — управление миграциями БД


